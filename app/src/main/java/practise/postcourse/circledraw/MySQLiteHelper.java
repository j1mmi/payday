package practise.postcourse.circledraw;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.util.Log;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class MySQLiteHelper extends SQLiteOpenHelper {
	
	// Database Version
    private static final int DATABASE_VERSION = 1;
    // Database Name
    public static final String DATABASE_NAME = "CircleDrawDB";
    //Logging tag
    public static final String TAG = "MYSQLiteHelper";
   
	public MySQLiteHelper(Context context) {
		super(context, DATABASE_NAME, null, DATABASE_VERSION);	
	}

	@Override
	public void onCreate(SQLiteDatabase db) {
		// SQL statement to create transaction table
		String CREATE_TRANS_TABLE = "CREATE TABLE transactions ( " +
                "_id INTEGER PRIMARY KEY AUTOINCREMENT, " +
				"from_user_id TEXT, "+
                "from_user_name TEXT, "+
                "to_user_id TEXT, "+
                "to_user_name TEXT, "+
				"amount INT, " +
                "currency TEXT, " +
                "description TEXT )";

        db.execSQL(CREATE_TRANS_TABLE);

        // SQL statement to create user table
        String CREATE_USER_TABLE = "CREATE TABLE users ( " +
                "id TEXT, " +
                "short_name TEXT, "+
                "full_name TEXT, "+
                "color INT, " +
                "email TEXT)";

        db.execSQL(CREATE_USER_TABLE);

	}

	@Override
	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
		// Drop older debts table if existed
        db.execSQL("DROP TABLE IF EXISTS transactions");
        db.execSQL("DROP TABLE IF EXISTS users");
        
        // create fresh debts table
        this.onCreate(db);
	}
	//---------------------------------------------------------------------
	
	// TRANSACTION TABLE
    private static final String TABLE_TRANSACTIONS = "transactions";
    
    // transaction Table Columns names
    private static final String TRANS_ID = "_id";
    private static final String TRANS_FROM_USER_ID = "from_user_id";
    private static final String TRANS_FROM_USER_NAME = "from_user_name";
    private static final String TRANS_TO_USER_ID = "to_user_id";
    private static final String TRANS_TO_USER_NAME = "to_user_name";
    private static final String TRANS_AMOUNT = "amount";
    private static final String TRANS_CURRENCY = "currency";
    private static final String TRANS_DESC = "description";
    
    private static final String[] TABLE_TRANSACTIONS_COLUMNS = {TRANS_ID, TRANS_FROM_USER_ID, TRANS_FROM_USER_NAME,
            TRANS_TO_USER_ID, TRANS_TO_USER_NAME, TRANS_AMOUNT, TRANS_CURRENCY, TRANS_DESC};

    // USER TABLE
    private static final String TABLE_USERS = "users";

    // user Table Columns names
    private static final String USER_ID = "id";
    private static final String USER_SHORTNAME = "short_name";
    private static final String USER_FULLNAME = "full_name";
    private static final String USER_COLOR = "color";
    private static final String USER_EMAIL = "email";

    private static final String[] TABLE_USERS_COLUMNS = {USER_ID, USER_SHORTNAME, USER_FULLNAME, USER_COLOR, USER_EMAIL};

    // TRANSACTION TABLE CALLS:

    public int addTransactionToTable(Transaction t) {

        // get reference to writable DB
        SQLiteDatabase db = this.getWritableDatabase();

        // create ContentValues to add key "column"/value
        ContentValues values = new ContentValues();
        values.put(TRANS_FROM_USER_ID, t.getFromUserID());
        values.put(TRANS_FROM_USER_NAME, t.getFromUserName());
        values.put(TRANS_TO_USER_ID, t.getToUserID());
        values.put(TRANS_TO_USER_NAME, t.getToUserName());
        values.put(TRANS_TO_USER_ID, t.getToUserID());
        values.put(TRANS_AMOUNT, t.getAmount());
        values.put(TRANS_CURRENCY,t.getCurrency());
        values.put(TRANS_DESC, t.getDescription());

        // insert this into table
        db.insert(TABLE_TRANSACTIONS, // table
                null, //nullColumnHack
                values); // key/value -> keys = column names/ values = column values

        Log.d(TAG, "addTransactionToTable: " + t.toString());

        // request last _id generated by insert above
        String query = "select last_insert_rowid()";

        // get cursor
        Cursor c = db.rawQuery(query,null);

        // return value will be -1 by default
        int id = -1;

        if (c.moveToFirst()) {
            // get id value from cursor
            id = c.getInt(0);
        }

        // close table
        db.close();

        return id;
    }

    public Transaction getTransactionFromTable(long id) {

        // get reference to writable DB
        SQLiteDatabase db = this.getWritableDatabase();

        String query = "SELECT * FROM " + TABLE_TRANSACTIONS + " WHERE " + TRANS_ID + " = " + id;

        Cursor c = db.rawQuery(query, null);

        if (c.moveToFirst()) {
            return new Transaction(
                    c.getString(c.getColumnIndex(TRANS_FROM_USER_ID)),
                    c.getString(c.getColumnIndex(TRANS_FROM_USER_NAME)),
                    c.getString(c.getColumnIndex(TRANS_TO_USER_ID)),
                    c.getString(c.getColumnIndex(TRANS_TO_USER_NAME)),
                    c.getInt(c.getColumnIndex(TRANS_AMOUNT)),
                    c.getString(c.getColumnIndex(TRANS_CURRENCY)),
                    c.getString(c.getColumnIndex(TRANS_DESC)));
        }
        // return nothing if no cursor is generated
        return null;

    }

    public String[] getUserCurrencies(String UserId) {

        // get reference to readable DB
        SQLiteDatabase db = this.getReadableDatabase();

        String query = "SELECT DISTINCT(" + TRANS_CURRENCY + ") FROM " + TABLE_TRANSACTIONS +
                " WHERE " + TRANS_TO_USER_ID + "=\"" + UserId + "\"" +
                " OR " + TRANS_FROM_USER_ID + "=\"" + UserId + "\"";

        Cursor c = db.rawQuery(query, null);
        if (c.moveToFirst()) {
            int size = c.getCount();
            String[] currencies = new String[size];
            for (int i = 0; i < size; i++) {
                currencies[i] = c.getString(0);
                c.moveToNext();
            }
            return currencies;
        }
        return new String[]{"NULL"};
    }

    public Cursor getTransactionsFromTable(int[] ids) {

        // get reference to writable DB
        SQLiteDatabase db = this.getReadableDatabase();

        ArrayList<Transaction> array = new ArrayList<>();

        String query = "SELECT * FROM " + TABLE_TRANSACTIONS + " WHERE " + TRANS_ID + " = " + String.valueOf(ids[0]);
        for (int i = 1; i < ids.length; i++) {
            query += " OR " + TRANS_ID + " = " + String.valueOf(ids[i]);
        }

        return db.rawQuery(query, null);

    }

    public boolean hasTransactions(String UserId) {
        // get reference to writable DB
        SQLiteDatabase db = this.getReadableDatabase();

        String query = "SELECT * FROM " + TABLE_TRANSACTIONS + " WHERE (" + TRANS_FROM_USER_ID + " = \"" + UserId + "\""
                + " OR " + TRANS_TO_USER_ID + " = \"" + UserId + "\"" + ") AND " + TRANS_AMOUNT + " != 0";

        int c = db.rawQuery(query,null).getCount();

        db.close();

        Log.d(TAG, "hasTransactions: " + c);

        if (c > 0) return true;

        return false;

    }

    public void updateTransNameDetails(String id, String new_name) {
        // get reference to writable DB
        SQLiteDatabase db = this.getWritableDatabase();

        ContentValues values = new ContentValues();
        values.put(TRANS_FROM_USER_NAME, new_name);

        int count = db.update(TABLE_TRANSACTIONS, values,
                TRANS_FROM_USER_ID + " = \"" + id + "\"", null);

        values = new ContentValues();
        values.put(TRANS_TO_USER_NAME, new_name);

        count += db.update(TABLE_TRANSACTIONS, values,
                TRANS_TO_USER_ID + " = \"" + id + "\"", null);

        Log.d(TAG, "updateTransNameDetails: count = " + count);

        db.close();

    }

    public void deleteUserTransactions(String UserId) {
        // get reference to writable DB
        SQLiteDatabase db = this.getWritableDatabase();

        String query = "DELETE FROM " + TABLE_TRANSACTIONS + " WHERE " + TRANS_FROM_USER_ID + " = \"" + UserId + "\""
                + " OR " + TRANS_TO_USER_ID + " = \"" + UserId + "\"";

        db.execSQL(query);

        Log.d(TAG, "removeAllUserTrans: ");

        db.close();

    }

    public void deleteTransactionFromTable(int id) {

        // get reference to writable DB
        SQLiteDatabase db = this.getWritableDatabase();

        // delete
        db.delete(TABLE_TRANSACTIONS, TRANS_ID + "=" + id, null);

        Log.d(TAG, "removeTransFrmTable: " + id);

        // close
        db.close();
    }

    public void deleteTransactionsFromTable(String id_list) {
        String[] id_array = id_list.split(",");

//        for (String id: id_array) {
//            System.out.println(id);
//        }
        // get reference to writable DB
        SQLiteDatabase db = this.getWritableDatabase();
        for (String s: id_array) {
            // delete
            db.delete(TABLE_TRANSACTIONS, TRANS_ID + "=" + s, null);
        }

        Log.d(TAG, "removeTranssFrmTable: " + id_list);

        // close
        db.close();
    }

    public void clearTransactionTable() {

        // get reference to writable DB
        SQLiteDatabase db = this.getWritableDatabase();

        // delete all transactions in the table
        db.delete(TABLE_TRANSACTIONS, null, null);

        Log.d(TAG, "TRANSACTION TABLE DELETED!");

        db.close();

    }

    public void setTransactionAmountToZero(long trans_id) {
        SQLiteDatabase db = this.getWritableDatabase();

        ContentValues content = new ContentValues();
        content.put(TRANS_AMOUNT, 0);

        db.update(TABLE_TRANSACTIONS, content, TRANS_ID + "=" + trans_id, null);

        db.close();
    }

    public void setTransactionAmount(long trans_id, int amount) {
        SQLiteDatabase db = this.getWritableDatabase();

        ContentValues content = new ContentValues();
        content.put(TRANS_AMOUNT, amount);

        db.update(TABLE_TRANSACTIONS, content, TRANS_ID + "=" + trans_id, null);

        db.close();
    }

    public Cursor getSummaryCursor(String user_id) {

        // get reference to writable DB
        SQLiteDatabase db = this.getWritableDatabase();

        // build the query
        String query = "SELECT * FROM " + TABLE_TRANSACTIONS +
                " WHERE (" + TRANS_TO_USER_ID + "=\"" + user_id + "\"" +
                " OR " + TRANS_FROM_USER_ID + "=\"" + user_id + "\"" +
                ") AND " + TRANS_AMOUNT + " != 0";

        // logging
        Log.d(TAG, "getSummaryCursor: " + user_id);

        // return cursor
        return db.rawQuery(query, null);
    }

    public Cursor getSummaryCursor(String user_id, String currency) {

        // get reference to writable DB
        SQLiteDatabase db = this.getWritableDatabase();

        // build the query
        String query = "SELECT * FROM " + TABLE_TRANSACTIONS +
                " WHERE (" + TRANS_TO_USER_ID + "=\"" + user_id + "\"" +
                " OR " + TRANS_FROM_USER_ID + "=\"" + user_id + "\"" +
                ") AND " + TRANS_AMOUNT + " != 0" +
                " AND " + TRANS_CURRENCY + "=\"" + currency + "\"";

        // logging
        Log.d(TAG, "getSummaryCursor: " + user_id + ", " + currency);

        // return cursor
        return db.rawQuery(query, null);
    }

    public float getUserCurrencyTotal(String user_id, String currency) {

        // get reference to writable DB
        SQLiteDatabase db = this.getWritableDatabase();

        // set placeholders for cursor output
        int positive = 0;
        int negative = 0;

        // get total amount owed to the user id in the currency

        String query = "SELECT SUM(" + TRANS_AMOUNT +
                ") FROM " + TABLE_TRANSACTIONS +
                " WHERE " + TRANS_TO_USER_ID + "=\"" + user_id + "\"" +
                " AND " + TRANS_CURRENCY + "=\"" + currency + "\"";

        Cursor c = db.rawQuery(query, null);

        if (c.moveToFirst()) {
            positive = c.getInt(0);
        }

        // get total amount the user id owes in the currency

        query = "SELECT SUM(" + TRANS_AMOUNT +
                ") FROM " + TABLE_TRANSACTIONS +
                " WHERE " + TRANS_FROM_USER_ID + "=\"" + user_id + "\"" +
                " AND " + TRANS_CURRENCY + "=\"" + currency + "\"";

        c = db.rawQuery(query, null);

        if (c.moveToFirst()) {
            negative = c.getInt(0);
        }

        return (float) (positive - negative) / 100;

//        // return total value
//        return String.format("%.2f", (float) total / 100);
    }



    public ArrayList<Total> getAllSummaryTotals() {

        // get reference to writable DB
        SQLiteDatabase db = this.getWritableDatabase();
        ArrayList<Total> array = new ArrayList<>();

        String query = "SELECT GROUP_CONCAT(" + TRANS_ID + "), " + TRANS_FROM_USER_ID + ", " + TRANS_FROM_USER_NAME + ", " +
                TRANS_TO_USER_ID + ", " + TRANS_TO_USER_NAME + ", SUM(" + TRANS_AMOUNT + "), " +
                TRANS_CURRENCY + " FROM " + TABLE_TRANSACTIONS +
                " GROUP BY " + TRANS_FROM_USER_ID + ", " +  TRANS_TO_USER_ID  + ", " + TRANS_CURRENCY;

        Cursor c = db.rawQuery(query, null);

        if (c.moveToFirst()) {
            do {
                if (c.getInt(c.getColumnIndex("SUM(" + TRANS_AMOUNT + ")")) > 0) {
                    array.add(new Total(
                            c.getString(c.getColumnIndex(TRANS_FROM_USER_ID)),
                            c.getString(c.getColumnIndex(TRANS_FROM_USER_NAME)),
                            c.getString(c.getColumnIndex(TRANS_TO_USER_ID)),
                            c.getString(c.getColumnIndex(TRANS_TO_USER_NAME)),
                            c.getInt(c.getColumnIndex("SUM(" + TRANS_AMOUNT + ")")),
                            c.getString(c.getColumnIndex(TRANS_CURRENCY)),
                            c.getString(c.getColumnIndex("GROUP_CONCAT(" + TRANS_ID + ")"))));
                }
            } while (c.moveToNext());
        }

        // logging
        Log.d(TAG, "getAllSummaryTotals: count: " + c.getCount());

        Log.d(TAG, "getAllSummaryTotals: item: " + array);

        return array;
    }

    // USER TABLE CALLS:

    public void createNewUser(User user) {

        // get reference to writable DB
        SQLiteDatabase db = this.getWritableDatabase();

        // create ContentValues to add key "column"/value
        ContentValues cV = new ContentValues();
        cV.put(USER_ID, user.getId());
        cV.put(USER_COLOR, user.getRingColor());
        cV.put(USER_SHORTNAME, user.getShortName());
        cV.put(USER_FULLNAME, user.getFullName());
        cV.put(USER_EMAIL, user.getEmail());

        // insert this into table
        db.insert(TABLE_USERS, // table
                null, //nullColumnHack
                cV); // key/value -> keys = column names/ values = column values

        Log.d(TAG, "addUserToTable: ID: " + user.getId() + "; name: " + user.getShortName());

        // close table
        db.close();
    }

    public void updateUser(User user) {
        // get reference to writable DB
        SQLiteDatabase db = this.getWritableDatabase();

        ContentValues cV = new ContentValues();
        cV.put(USER_COLOR, user.getRingColor());
        cV.put(USER_SHORTNAME, user.getShortName());
        cV.put(USER_FULLNAME, user.getFullName());
        cV.put(USER_EMAIL, user.getEmail());

        db.update(TABLE_USERS, cV, USER_ID + "=\"" + user.getId() + "\"", null);

        Log.d(TAG, "updateUser: updated " + user.getId());

        db.close();
    }

    public void deleteUser(String id) {
        // get reference to writable DB
        SQLiteDatabase db = this.getWritableDatabase();

        db.delete(TABLE_USERS, USER_ID + " = \"" + id + "\"", null);

        Log.d(TAG, "deleteUser: " + id);

        // close
        db.close();

    }

    public void clearUserTable() {

        // get reference to writable DB
        SQLiteDatabase db = this.getWritableDatabase();

        // delete all transactions in the table
        db.delete(TABLE_USERS, null, null);

        Log.d(TAG, "USER TABLE DELETED!");

        db.close();
    }

    public Cursor getAllUsers() {
        // get reference to readable DB
        SQLiteDatabase db = this.getReadableDatabase();

        // build the query
        String query = "SELECT * FROM " + TABLE_USERS;

        //get cursor
        Cursor c = db.rawQuery(query, null);

        // logging
        Log.d(TAG,"Getting all users; count = " + c.getCount());

        // return cursor
        return c;
    }


    public String getUserFullName(String id) {
        // get reference to readable DB
        SQLiteDatabase db = this.getReadableDatabase();

        // build the query
        String query = "SELECT " + USER_FULLNAME + " FROM " + TABLE_USERS + " WHERE " + USER_ID + " = \"" + id + "\"";

        //get cursor
        Cursor c = db.rawQuery(query, null);

        String fullname = "";

        if (c.moveToFirst()) {
             fullname = c.getString(c.getColumnIndex(USER_FULLNAME));
        }

        // logging
        Log.d(TAG,"Getting user; name = " + fullname);

        c.close();

        // return cursor
        return fullname;
    }
}
